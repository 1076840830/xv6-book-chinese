# 第二章
## 操作系统结构
操作系统的关键需求在于同时支持多个活动，比如进程可以调用在第零章中描述的系统调用接口fork来创建新进程，因此操作系统必须在这些进程中分时共享资源，比如进程的数量多于硬件的核心数的时候，操作系统必须保证所有进程都正常运行，因此就必须配置资源并隔离进程。也就是说，如果进程有bug或者运行失败，不能影响哪些不依赖次失败进程的其他进程运行。然而要求进程之间完全隔离有些太苛刻了，毕竟进程之间还需要相互通信，比如管道；也就是说，操作系统必须满足三个要求：多路复用、隔离以及交互。

本章主要概括了操作系统是如何满足上述的三个要求的。存在很多方法满足这些需求，但是本书中主要集中讨论的是以宏内核为中心的主流设计，该设计也被运用在unix操作系统中。本章通过追踪xv6启动是首进程的创建过程过来介绍xv6的设计，这样做也描述了xv6主要抽象的的具体实现、如何交互的，以及如何满足多路复用、隔离和交互的要求。xv6提供了标准操作实现代码复用，竭力避免首进程的特殊情况。后续章节将详细的探索各类抽象的细节。

xv6运行在Intel 80386或者x86的普通PC平台上，多数底层的功能(比如进程的实现)只针对x86架构。本书确保读者只需要少量的汇编层面的编程，并且会介绍提出x86架构的想法。附录A概要地总结了PC平台。

## 抽象物理资源
当你首次接触操作系统的时候，或许你首先思考的问题是为什么需要操作系统呢？我们完全可以把图0-2中的系统调用以库的方式实现，这样每个应用程序都可以根据需求量身定制所需的资源，也可以直接和硬件资源交互，通过最佳的方式来使用这些资源（比如达到很高或者可预测的性能）。某些嵌入式和实时操作系统确实是以这种方式组织的。

库文件方式的缺点是，如果有多个应用同时运行时，那么这些应用都必须循规蹈矩，比如每个应用都必须周期性的释放资源，以便其他应用运行。这种分时合作的机制在所用的应用程序都相互信任以及程序没有BUG的时候是可行的。但是典型的情况是应用程序彼此之间并不信任，程序也不能做到完全没有BUG，因此我们需要更加有效的合作机制来提供更健壮的隔离。

实现更健壮的隔离能有效禁止应用程序直接访问计算机敏感资源，以及将资源抽象为服务。比如，应用程序只能通过open、read、write以及close系统调用与文件系统交互，而不是直接在磁盘扇区读写。文件系统提供文件名，允许操作系统（接口的实现者）来管理磁盘。

相似的，操作系统在不同进程间切换，这种切换对于进程是透明的，在必要的时候保存和恢复寄存器的状态，因此应用程序不用担心分时共享，即使应用程序处于无限循环中，这种透明性也允许操作系统共享处理器。

另外一个例子，Unix进程使用exec来构建它的内存映象，而不是直接和物理内存交互。这允许操作系统可以决定在内存中的何处存放进程映象，如果内存不足，操作系统甚至可以将某些进程的数据存储在磁盘中。exec利用便捷的文件系统为用户存储可执行的程序映象。

多数Unix进程之间的交互都是通过文件描述符来完成，文件描述符不仅抽象了许多细节（比如管道中的数据和文件存储的地方），并且通过这种方式来简化交互。比如，比如管道中的某个应用运行失败，内核会在管道中为下个进程传入文件结束的标志。

你将明白为了向程序员提供便利以及实现健壮的隔离，图0-2中的系统系统是如何被精心设计的。unix接口不是资源抽象的唯一方法，但却被证明是最佳的一个。

## 用户模式，系统模式，以及系统调用
健壮的隔离需要在应用程序和操作系统有很好的边界。如果应用程序犯了错误，我们不像操作系统也挂掉。实际上，操作系统能够清理运行失败的应用程序，并继续运行其他应用程序。应用程序不能操作系统的数据结构和指令，也不能访问其他进程的内存等等。

处理器为健壮的隔离提供了硬件上的支持，比如，和许多其他处理器一样，x86处理器有两种执行指令的模式，分别是内核模式和用户模式。在内核模式下，处理器允许执行特权指令，比如，磁盘（或者其他I/O设备）读写都涉及到特权指令。如果一个应用在用户模式下尝试执行特权指令，处理器不会执行指令，而是切换到内核模式，以便内核中的软件能够清理该应用程序，因为该应用程序做了它不该做的事情。应用程序只能执行用户模式指令（比如加法等等），那它是运行在用户空间的；而内核模式下的软件能够执行特权指令，也就是说是在内核模式下运行的。运行在内核空间（或者内核模式）的软件称为内核。

应用程序想要向磁盘读写的时候，必须过渡到内核去处理，因为应用程序本身不能执行I/O指令。处理器提供给了特殊的指令将处理器从用户模式切换到内核模式，并进入内核指定的内核指定的入口开始执行（x86处理器提供了int指令完成模式切换）。一旦处理器切换到内核模式，内核可以验证系统调用的参数，决定应用程序是否被允许执行请求的操作，然后选择拒绝还是执行调用。内核设置模式切换的入口非常重要，如果应用程序能够决定内核的入口，恶意应用程序能够从不需要参数验证的入口渐入内核模式。

## 内核组织
一个至关重要的设计问题是操作系统的那些部分因该在内核模式下运行，其中一种可能是整个操作系统都在内核中，以便所有的系统调用的实现都在内核中运行。这种组织方式称为宏内核。

在这种组织方式中，这个操作系统都运行在完全特权模式下，同时也是非常便利，因为操作系统设计者不必选择操作系统的那些部分不需要在完全特权模式下执行。因此很容让操作系统的不同部分协同工作。比如，操作系统的缓冲区可以被文件系统和虚拟内存系统共享。

宏内核的劣势在于操作系统的不同部分之间的接口通常比较复杂（正如我们在本文中看到的），因此操作系统的开发人员非常容易犯错误。在宏内核中，错误是致命的，因为内核中的错误通畅会导致整个内核都挂掉。如果内核挂掉，那计算机将停止工作，因此所有的应用程序也会跟着挂掉，计算机必须再次重启。

为了减少内核中错误的风险，操作系统设计者可以最小化运行在内核模式下的代码，在用户模式下执行大量的操作系统，这种内核设计称为微内核。

图1-1揭示了宏内核的设计，图中的文件系统作为用户进程运行。操作系统服务作为进程运行简称为服务。为了允许进程和文件服务交互，内核提供了进程间的通信机制把一个用户进程的消息发送给另一个。比如，如果shell应用程序想要读写文件，它发送消息给文件服务并等到响应。

在宏内核中，内核接口有为启动应用程序、发送消息和访问设备硬件等底层函数组成。多数操作系统都是用户模式下的服务，这种组织方式允许内核相对简洁。

在现实的世界中，可以找到宏内核和微内核两种。比如，Linux是宏内核，尽管部分OS功能作为用户层服务（比如视窗系统）。Xv6是宏内核的实现，遵循多数Unix的设计。因此，在xv6中，内核接口关联操作系统接口，内核实现了整个操作系统。xv6并不提供许多服务，它的内核比其他微内核还小。

## 进程概述
xv6中的隔离单元是进程（其他Unix操作系统也是）。进程抽象防止进程破坏或者嗅探其他进程的内存、CPU以及文件描述符等。也防止进程破坏内核本身，更不能绕过内核的隔离机制。内核必须细心地实现进程抽象，因为满是bug或者恶意应用可以绕过内核和硬件做坏事。内核实现进程的机制包括用户／内核模式标志，地址空间和线程分时。

为了实现进程强制隔离，进程抽象让程序以为有自己的私有机器，进程提供给程序的私有内存或者地址空间不能被其它进程读写。进程也让程序像在自己的CPU上执行程序指令。

Xv6使用分页表（这是由硬件实现的）来为每个进程分配自己的地址空间。x86分页表将虚拟地址（x86指令操作的地址）映射到物理地址（处理器送到主内存中的地址）。

Xv6维护为每个进程的内存空间分配的分页表，如图1-2所示，地址空间包括了从0开始的进程用户内存，首先是指令，接着是全局变量，然后栈空间，最后是进程可以按需扩展堆区域（用于malloc）。

进程的内核指令、数据和用户程序内存都同样被映射进程的地址空间中，当进程请求系统调用，系统调用执行在进程的地址空间的内核映射中。这中组织方式以便内核的系统调用代码能够直接访问用户的内存。为了给用户内存流出大量的空间，xv6将内核映射到高地址0x80100000。

Xv6在proc结构体中维护了许多进程状态信息，其中最重的内核状态就是分页表、内核栈以及运行状态。我们将使用p->xxx的记号来引用proc结构体中的元素。

每个进程都有执行的线程来执行进程的指令。线程可以被挂起随后再恢复。为了在进程间透明的切换，内核必须挂起当前运行的线程然后恢复另一个进程的线程。多数线程的状态存书在线程的占空间内。每个进程有两个占空间：用户栈和内核栈(p->kstack)。当进程在执行用户指令的时候，只有用户栈可用，其内核栈为空；当进程进入内核的时候，内核代码执行在进程的内核栈中。然而进程在内核模式下的时候，它的用户栈仍然含有保存着的数据，但是没有使用。进程的线程交替使用它的用户栈和内核栈。内核栈被隔开，因此即使进程有损坏它的用户栈，但是内核依旧可以执行。

当进程请求系统调用，处理器切换到内核栈，提升硬件的权限等级，开始执行实现系统调用的内核。当系统调用完成，从内核返回到用户空间：硬件降低它的权限等级，切换回用户栈，并且在系统调用指令执行完后继续执行用户指令。进程的线程可以被内核中的I/O等待所阻塞，在I/O完成后重新开始恢复运行。

p->state表示进程是否被分配、已经准备好可以运行、I/O等待或者退出等。

p->pgdir保存了x86硬件期望的进程分页表，当执行进程的时候，xv6会让分页硬件使用进程的p->pgdir。进程的分页表页记录了分配给进程的内存物理页的地址。

## 代码：首地址空间
现在我们看看内核是如何创建用户级别的进程和被健壮地隔离的。main(行1317)初始化设备和子系统之后，它创建了一个称为userinit(行2502)，userinit的第一个动作就是调用allocproc。allocproc的工作就是分配一个进程表中的proc结构体，并初始化内核线程执行所需的进程的状态，每次新进程都会调用allocproc，而userinit则是最先创建的进程。alooclproc扫描proc表，找到一个状态为UNUSED（2461-2463）。当发现一个没有使用的proc时，allocproc设置其状态EMBRYO
